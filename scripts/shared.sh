#!/usr/bin/env bash

ROOT="$( cd "$( dirname "$0" )/../.." && pwd )"

TARGETS=$ROOT/targets
TARGET_CONFIGS="$HOME/.config/dotfiles"

BASHRC="$HOME/.bashrc"
BASHPROFILE="$HOME/.bash_profile"

is_mac() {
  local unamestr=`uname`
  test $unamestr == 'Darwin'
}

is_linux() {
  local unamestr=`uname`
  test $unamestr == 'Linux'
}

get_target_name() {
  local target_dir=$( cd "$( dirname "$0" )" && pwd )
  echo $(basename "$target_dir")
}

get_target_config() {
  local target=$(get_target_name)
  echo "$TARGET_CONFIGS/$target"
}

get_source() {
  local name=$(get_target_name)
  echo $TARGETS/$name
}

is_sourced() {
   if [ -n "$ZSH_VERSION" ]; then 
       case $ZSH_EVAL_CONTEXT in *:file:*) return 0;; esac
   else  # Add additional POSIX-compatible shell names here, if needed.
       case ${0##*/} in dash|-dash|bash|-bash|ksh|-ksh|sh|-sh) return 0;; esac
   fi
   return 1  # NOT sourced.
}

message() {
  local message="$1"
  local color=${2:-35}
  local target=$(get_target_name)
  echo -e "\033[${color}mDOTFILES($target):\033[0m $message"
}

error() {
  local message=${1:-"Something went wrong"}
  local code=${2:-1}
  local color=31
  message "$message" 31
  return $code
}

log() {
  message "$1" 35
}

assert_prev() {
  local message=${1:-"Something went wrong"}
  local code=${2:-1}
  [[ $? != 0 ]] && error $message $code && sleep 5m
}

tolower() {
  echo $(echo $1 | tr '[:lower:]' '[:upper:]')
}

tolower() {
  echo $(echo $1 | tr '[:upper:]' '[:lower:]')
}

yesno() {
  local display=$1; shift
  local default=$(tolower ${1:-yes}); shift
  while true
  do
    if [[ $default == "yes" ]]; then
      echo "${display} YES/no?"
    else
      echo "${display} yes/NO?"
    fi

    read -r answer
    [[ -z "$answer" ]] && answer=$default

    answer=$(tolower $answer)
    case $answer in
      yes)
        return 0
        ;;
      no)
        return 1
        ;;
      *)
        error "You must choose between \"yes\" or \"no\""
        ;;
    esac
  done
}

bash_newline() {
  local target_config=$(get_target_config)
  echo $1 >> $target_config
}

bash_section() {
  bash_newline
  bash_newline "# $1"
}

# Creates a target specific bash file, e.g. in ~/.config/dotfiles/<TARGET>.
# <TARGET> is the name of the directory containing the executing bash script.
# This file is then sources from ~/.bashrc. If the target file already exists,
# it is cleared and it is assumed it is already sources from ~/.bashrc
bash_init_config() {
  if [ ! -d "$TARGET_CONFIGS" ]; then
    log "Create '$TARGET_CONFIGS'"
    mkdir -p $TARGET_CONFIGS
  fi

  local target_config=$(get_target_config)
  if [ ! -f "$target_config" ]; then
    log "Sourcing '$TARGET_CONFIGS' from $BASHRC"
    echo "source $target_config" >> $BASHRC
  fi

  log "Initialising '$target_config'"
  rm -f $target_config >& /dev/null
  bash_newline "#!/usr/bin/env bash"
  bash_newline
  bash_newline "# This file is automatically generated by the installer." 
  bash_newline "# Do NOT change anything here!"
  bash_newline 
  bash_newline "# Do nothing if this shell isn't on the first level"
}

bash_export_path() {
  local target_config=$(get_target_config)
  echo "export PATH=\"$1:\$PATH\"" >> $target_config
}

bash_export_source() {
  local target_config=$(get_target_config)
  echo "source $1" >> $target_config
}

bash_export_source_maybe() {
  local target_config=$(get_target_config)
  echo "if [ -f \"$1\" ]; then" >> $target_config
  echo "  source $1" >> $target_config
  echo "fi" >> $target_config
}

bash_export_global() {
  local target_config=$(get_target_config)
  echo "export $1=$2" >> $target_config
}
