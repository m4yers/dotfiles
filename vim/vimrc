set nocompatible              " be iMproved, required
filetype off                  " required

" set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()

Plugin 'FSwitch'
Plugin 'gmarik/Vundle.vim'
Plugin 'Lokaltog/vim-easymotion'
Plugin 'kshenoy/vim-signature'
Plugin 'Valloric/YouCompleteMe'
Plugin 'rdnetto/YCM-Generator'
Plugin 'Chiel92/vim-autoformat'
Plugin 'Valloric/Vim-Jinja2-Syntax'
Plugin 'justinmk/vim-syntax-extra'
Bundle 'solarnz/thrift.vim'
Bundle 'wannesm/wmgraphviz.vim'
Plugin 'kien/ctrlp.vim'
Plugin 'scrooloose/syntastic'
Plugin 'scrooloose/nerdtree'
Plugin 'SirVer/ultisnips'
Plugin 'honza/vim-snippets'
Plugin 'bling/vim-airline'
Plugin 'Raimondi/delimitMate'
Plugin 'morhetz/gruvbox'
Plugin 'tpope/vim-fugitive'
Plugin 'tpope/vim-git'
Plugin 'majutsushi/tagbar'
Plugin 'suan/vim-instant-markdown'
Plugin 'tomtom/tcomment_vim'
Plugin 'xolox/vim-misc'
Plugin 'xolox/vim-session'
Plugin 'rizzatti/dash.vim'

call vundle#end()
filetype plugin indent on

set rtp+=~/Development/Projects/dotfiles/vim/after
set spellfile=~/Development/Projects/dotfiles/vim/spell/en.latin1.add

"" Plugins

" Airline
if !exists('g:airline_symbols')
    let g:airline_symbols = {}
endif

let g:airline_powerline_fonts = 1
let g:airline_symbols.linenr = 'LN'
let g:airline_detect_paste = 0
let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#whitespace#show_message = 1

" Syntastic
let g:syntastic_error_symbol = '✗'
let g:syntastic_warning_symbol = '⚠'
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_cpp_include_dirs = ['/usr/local/Cellar/boost/1.57.0/include']

"
" General
syntax on

augroup vimrc
    autocmd!

    "
    " Reload .vimrc
    autocmd bufwritepost .vimrc source $MYVIMRC

    "
    " When editing a file, always jump to the last known cursor position.
    " Don't do it when the position is invalid or when inside an event handler
    " (happens when dropping a file on gvim).
    " Also don't do it when the mark is in the first line, that is the default
    " position when opening a file.
    autocmd BufReadPost *
        \ if line("'\"") > 1 && line("'\"") <= line("$") |
        \   exe "normal! g`\"" |
        \ endif

    "
    " ActionScript 3
    autocmd BufRead,BufNewFile *.as set filetype=as3
augroup END

set backspace=indent,eol,start
set clipboard=unnamed
set ambiwidth=single
set laststatus=2
set noshowmode
set ttimeoutlen=50
set wildmenu
set history=50
set incsearch

"
" Backup
"set nobackup
"set nowritebackup
"set noswapfile
set backupdir=~/.tmp/vim,~/tmp/vim,~/.tmp,~/tmp,/var/tmp,/tmp
set directory=~/.tmp/vim,~/tmp/vim,~/.tmp,~/tmp,/var/tmp,/tmp

"
" Encoding
scriptencoding utf-8
set encoding=utf-8

"
" Indentation
set autoindent
set smartindent
set tabstop=4
set softtabstop=4
set shiftwidth=4
set expandtab

"
" View
set ruler
set number
set showcmd
set cursorline
set hlsearch
set t_Co=256
set colorcolumn=99
set background=dark
colorscheme gruvbox
if has("gui_running")
    set guifont=Menlo\ For\ Powerline:h12
    set guioptions=gtm
    set visualbell t_vb="
endif

"
" When you type the first tab, it will complete as much as possible, the second
" tab hit will provide a list, the third and subsequent tabs will cycle through
" completion options so you can complete the file without further keys
set wildmode=longest,list,full
set wildmenu            " completion with menu

"
" This changes the default display of tab and CR chars in list mode
set listchars=tab:▸\ ,eol:¬

"
" KEYS
"
let mapleader = " "

" Leave insert and command mode
inoremap <C-i> <ESC>
cnoremap <C-i> <C-c>

"
" Tabs
map <Tab>t :tabnew<CR>
map <Tab>l :tabnext<CR>
map <Tab>h :tabprevious<CR>
map <Tab>0 :tabnext1<CR>
map <Tab>1 :tabnext2<CR>
map <Tab>2 :tabnext3<CR>
map <Tab>3 :tabnext4<CR>
map <Tab>4 :tabnext5<CR>
map <Tab>5 :tabnext6<CR>
map <Tab>6 :tabnext7<CR>
map <Tab>7 :tabnext8<CR>
map <Tab>8 :tabnext9<CR>
map <Tab>9 :tabnext10<CR>

"
" Splits
nmap <Tab>e :vsplit<CR>
nmap <Tab>o :split<CR>
nmap <Tab>d :bdelete<CR>

"
" Buffers and Windows
nmap <C-h> <C-w>h
nmap <C-j> <C-w>j
nmap <C-k> <C-w>k
nmap <C-l> <C-w>l

"
" Jumps
nmap J 5j
nmap K 5k
xmap J 5j
xmap K 5k

"
" nmap <Tab>j <C-]>
nmap <Tab>k <C-o>

"
" Padding
if has("gui_running")
    nmap <Enter> o<Esc>
    nmap <S-Enter> O<Esc>
else
    nmap <Enter> o<Esc>
    nmap ✠ O<Esc>
endif

"
" Saving
nmap <Leader>w :write<CR>
nmap <Leader>W :wq<CR>

"
" Replace
nmap <Leader>r :%s/\<<C-r><C-w>\>/<C-r><C-w>/g<Left><Left>

"
" Spelling
" ]s next misspelled word
" [s previous misspelled word
" zg add to dict
" z= get suggestions
noremap <Leader>sn ]s
noremap <Leader>sp [s
noremap <Leader>sa zg
noremap <Leader>su a<C-x>s
noremap <Leader>ss :setlocal spell! spelllang=en_us<cr>

""
"" Code formatting
"" file
"nmap <Leader>ff gggqG
"" line
"nmap <Leader>fl gqgq

"
" Buffer
nmap <Leader>br :edit<CR>

"
" PLUGINS
"

"
" EasyMotion
nmap s <Plug>(easymotion-s)

" UltiSnips
let g:snips_author = "Artyom Goncharov"
let g:UltiSnipsSnippetDirectories = ["UltiSnips"]
let g:UltiSnipsJumpBackwardTrigger = "<c-h>"
let g:UltiSnipsJumpForwardTrigger = "<c-l>"
if has("gui_running")
    let g:UltiSnipsExpandTrigger = "<C-Space>"
else
    let g:UltiSnipsExpandTrigger = "<Nul>"
endif
"let g:UltiSnipsEditSplit="vertical"

"
" YouCompleteMe
let g:ycm_complete_in_comments = 1
let g:ycm_autoclose_preview_window_after_completion = 1
let g:ycm_goto_buffer_command = 'new-tab'
let g:ycm_key_invoke_completion = ''
"let g:ycm_add_preview_to_completeopt = 0
"set completeopt-=preview
"let g:ycm_autoclose_preview_window_after_insertion = 1

nmap <Leader>yd :YcmDebugInfo<CR>
nmap <Leader>yt :YcmCompleter GetType<CR>
nmap <Tab>j :YcmCompleter GoTo<CR>

"
" FSwitch
nnoremap <Leader>jj :FSHere<cr>
nnoremap <Leader>jr :FSSplitRight<cr>
augroup vimrc
    au!
    au BufEnter *.cpp let b:fswitchdst  = 'hpp,h'
    au BufEnter *.cpp let b:fswitchlocs = 'reg:/src/include/,reg:/Private/Public/,reg:|src|include/**|,../include'
    au BufEnter *.cc  let b:fswitchdst  = 'h'
    au BufEnter *.cc  let b:fswitchlocs = 'reg:/src/include/,reg:/Private/Public/,reg:|src|include/**|,../include'
    au BufEnter *.c   let b:fswitchdst  = 'h'
    au BufEnter *.c   let b:fswitchlocs = 'reg:/src/include/,reg:/Private/Public/,reg:|src|include/**|,../include'
    au BufEnter *.h   let b:fswitchdst  = 'cpp,cc,c'
    au BufEnter *.h   let b:fswitchlocs = 'reg:/include/src/,reg:/Public/Private/,reg:/include.*/src/,../src'
augroup END

"
" Autoformat
noremap <leader>ff :Autoformat<CR>

" C
let g:formatdef_astyle_c = '"astyle --mode=c --style=ansi --unpad-paren --pad-oper --pad-first-paren-out --pad-header --add-brackets --convert-tabs --align-pointer=middle --align-reference=name"'
let g:formatters_c = ['astyle_c']

" C++
let g:formatdef_astyle_cpp = '"astyle --mode=c --style=ansi --unpad-paren --pad-oper --pad-first-paren-out --pad-header --add-brackets --convert-tabs --align-pointer=middle --align-reference=name"'
let g:formatters_cpp = ['astyle_cpp']

" C#
let g:formatdef_astyle_cs = '"astyle --mode=cs --style=ansi --indent-namespaces -pcH".(&expandtab ? "s".&shiftwidth : "t")'
let g:formatters_cs = ['astyle_cs']


"
" NERDTree
map <F2> :NERDTreeToggle<CR><C-w>=
let NERDTreeWinSize = 30
autocmd bufenter * if (winnr("$") == 1
    \ && exists("b:NERDTreeType")
    \ && b:NERDTreeType == "primary") | q | endif

"
" Tagbar
let g:tagbar_autofocus = 1
let g:tagbar_width = 30

map <F3> :TagbarToggle<CR><C-w>=

"
" Dash
nmap <silent> <Leader>d :Dash<CR>

"
" Git
nmap <Leader>gs :Gstatus<CR>
nmap <Leader>gc :Gcommit<CR>
nmap <Leader>gb :Gblame<CR>

"
" Instant Markdown
let g:instant_markdown_autostart = 0

"
" Sessions
let g:session_default_overwrite = 0
let g:session_autosave_periodic = 1
let g:session_persist_colors    = 0
let g:session_autoload          = 'no'
let g:session_autosave          = 'yes'
let g:session_default_to_last   = 'yes'
let g:session_directory         = '~/tmp/vim/sessions'

"
" Gruvbox
let g:gruvbox_contrast_dark='medium'
let g:gruvbox_contrast_light='medium'
